<!DOCTYPE html>
<html>
  <head>
    <title>Microservices and Docker</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Oxygen);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Oxygen';
        font-weight: bold;
      }
      h5 {
        -webkit-margin-after: -0.8em;
      }
      .remark-code { font-size: 14px; }
      .row { display: flex; align-items: center; }
      .col { flex: 1; margin: 10px; }
      .image img { width: 100%; height: auto; }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 15%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 0;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

.image[
![Fox DCG](images/fox-dcg-logo-updated.png)
]

# Microservices and Docker
.row[
.col[.image[
![Fox](images/docker-logo.png)
]]
.col[.image[
![FX](images/consul-logo.png)
]]
.col[.image[
![FX](images/lerna-logo.png)
]]
.col[.image[
![FX](images/terraform-logo.png)
]]
]

---
# Who is FOX DCG
.row[
.col[.image[
![Fox](images/fox-logo.png)
]]
.col[.image[
![FX](images/fx-logo.png)
]]
.col[.image[
![National Geographic](images/nat-geo-logo.png)
]]
.col[.image[
![FOX Sports](images/fox-sports-logo.png)
]]
]

- Responsible for consumer video applications across FOX, FOX Sports, FX, and National Geographic, ie. FOXNOW, FXNOW, etc...

- Build APIs and services for client applications across all platforms

### About me

- At FOX 1.5 years, at Disney/ABC before that almost 10 years.

- Background as a full stack developer.


---
name: goals1
### Goals

#### Content/Data management (CMS) needs to be based on the same services as the client apps.
 - Client (iOS/Android app/etc...) always sees the same thing as the editor in the CMS.
 So CMS is really just a React/Redux front end for the same services that the client app uses.

 - Data can be sourced can be from a variety of places, each with different levels of quality or rules.
 So we need a way to translate or update the content before it is used.

 - Ability to override a single field on any platform but still inherit other fields.

---

Demo CMS

---
name: goals2
### Goals

#### Documentation needs to be simple and based on code.
 - Documentation is time consuming and will always get out of sync with code. So make it based on the code.

 - Exceptions happen so framework needs to be flexible to match.

 - Use Hypermedia driven web APIs, so that the apis are discoverable.

 - Products like apigee127 take similar but opposite approach.

---
name: models
##### Sample model:
```js
const SeriesModel = new Schema({
  approved: {
    type: Boolean,
  },
  contentFlags: {
    type: [String],
  },
  fullEpisodeCount: {
    type: Number,
  },
  previewVideo: {
    type: Collection,
    ref: 'Video',
    fields: ['@id', '@type', 'playerScreenUrl'],
  },
});
```

##### Sample draft (in) translation:
```js
class SeriesDraftTranslation extends Translation {
  contentFlags() {
    _.uniq(this._all('contentFlags').map(x => x.toLowerCase());
  }
}
```

##### Sample published (out) translation:
```js
class SeriesPublishedTranslation extends Translation {
  approved() {
    return this._get('cms.approved') && this._any('restriced') === false;
  }

  fullEpisodeCount() {
    return Video.count({ showId: this.id });
  }
}
```
---
name: swagger
##### Generates swagger
```json
{
  "swagger": "2.0",
  ...
  "paths": {
    "/series": {
      "get": {
        "produces": ["application/json"],
        "parameters": [{
          "name": "approved",
          "in": "query",
          "required": false,
          "type": "boolean"
        },
        ...
        "responses": "200": {
          "description": "Collection of Series objects",
          "headers": {
            ...
          },
          "schema": {
            "$ref": "#/definitions/SeriesCollection"
          }
        },
      }
    },
  },
  "definitions": {
    "Series": {
      "type": "object",
      "properties": {
        "@id": {
          "type": "string"
        },
        "approved": {
          "type": "boolean"
        },
        ...
      }
    }
  }
}
```
---
name: response
##### Generates response
```json
{
  "@platform": "default",
  "@id": "/series",
  "@context": "/context/core.jsonld",
  "@type": "Collection",
  "@populated": false,
  "itemsPerPage": 25,
  "totalItems": 201,
  "member": [{
    "@id": "/series/13-going-on-30_2004",
    "@type": "Series",
    "approved": true,
    "contentFlags": ["new", "expiring soon"],
    "fullEpisodeCount": 12,
    "previewVideo": {
      "@type": "Collection",
      ...
      "member": [{
        "@id": "/video/622258f933fc7f979a4358bb22a62d32",
        "@type": "Video"
      }]
    }
  },
  ...
  ]
}
```
---
name: goals3
### Goals

#### Easy for developers to work with, replicate, and deploy
 - Need to be able to run the entire environment and all services locally.

 - Desire to use the same tools and tooling that we work with everyday, whether you are developing a service, deploying code, or
 changing the infrastructure.

 - Need to be able to stamp out multiple environments or alternate builds with minimal effort.

 - Reuse code when possible, but not at the expense of keeping separation of services.

---
name: docker
.left-column[.image[![Fox](images/docker-logo.png)]]
.right-column[
### Docker
  - Provides us with consistent deployment artifacts.

  - Leverage a library of already built docker images. No need to worry about how to install consul, redis, elasticsearch, etc...

  - Easily share amongst developers the configuration.

  - Docker compose allows us to simulate the entire environment more easily and consistently.

  - Really easy to utilize environment variables as switches.

  - Utilizes our resources more effectively. Run multiple microservices on a single instance.

  - With terraform we can spin up an entire stack of microservices very quickly for one off tests or separate tests.
  (more on this later)
]
---
name:
##### Sample docker-compose.yml
```yml
version: "2"
services:
  service1:
    environment:
      SERVICE_NAME: "service1"
      SERVICE_8014_NAME: "service1-draft"
      SERVICE_8015_NAME: "service1-published"
      SERVICE_TAGS: "service1-path1,service1-path2"
    ports:
      - "8000:8000"
      - "8001:8001"
    depends_on:
      - es
      - mongo
  service2:
    environment:
      SERVICE_NAME: "service2"
      SERVICE_8012_NAME: "service2-draft"
      SERVICE_8013_NAME: "service2-published"
      SERVICE_TAGS: "service2-path1,service2-path2"
    ports:
      - "8002:8002"
      - "8003:8003"
    depends_on:
      - es
      - mongo
  mongo:
    ...
  es:
    ...
```
---
##### Sample docker-compose-override.yml
```yml
version: "2"
services:
  service1:
    extends:
      file: common.yml
      service: microservice
    ports:
      # debug ports
      - "7014:7000"
      - "7015:7001"
    volumes:
      - ./packages/service:/opt/app/service
```
##### Sample common.yml
```yml
version: "2"
services:
# shared microservices definitions
  microservice:
    image: service:local
    environment:
      NODE_ENV: "local"
    volumes:
      - ./packages/shared-package:/opt/app/shared-package
    mem_limit: 512m
```
---
name: lambda
### Why not use Lambda?

 - It is the future.

 - We still like to have visibility and full control of the application.

 - All of our code is actually built to work as a controller or as a handler function with Lambda so we can switch when ready.

 - When we started the local development and tooling wasn't quite ready.

---

## TODO

- create an architecture diagram
- show how the different services are used (who consumes them)

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
